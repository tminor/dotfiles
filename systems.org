#+TITLE: System Configuration with Guix
#+PROPERTY: header-args    :tangle-mode (identity #o444)
#+PROPERTY: header-args:sh :tangle-mode (identity #o555)

This file is essentially an exact copy of a file from David Wilson's
[[https://github.com/daviwil/dotfiles/blob/master/Systems.org][dotfiles repo]].

* Table of Contents
:PROPERTIES:
:TOC:      :include all :ignore this
:HASH:     9ac0242c1107cdb7db8f788a6f3ff189
:MODIFIED: [2021-06-28 Mon 14:14]
:ID:       42ded19b-53af-4956-aea5-08d994e59d15
:END:
:CONTENTS:
- [[#channels][Channels]]
- [[#systems][Systems]]
  - [[#base-configuration][Base Configuration]]
  - [[#machines][Machines]]
    - [[#per-system-settings][Per-System Settings]]
  - [[#usb-installation-image][USB Installation Image]]
- [[#profile-management][Profile Management]]
  - [[#activating-profiles][Activating Profiles]]
  - [[#updating-profiles][Updating Profiles]]
- [[#dotfiles-management][Dotfiles Management]]
  - [[#syncing][Syncing]]
  - [[#updating][Updating]]
- [[#nix-package-manager][Nix Package Manager]]
- [[#system-installation][System Installation]]
  - [[#building-the-installation-image][Building the Installation Image]]
  - [[#installing-guix][Installing Guix]]
    - [[#setting-up-wifi][Setting up WiFi]]
    - [[#setting-up-partitions][Setting Up Partitions]]
    - [[#initial-system-installation][Initial System Installation]]
    - [[#initial-system-setup][Initial System Setup]]
:END:

* Channels
:PROPERTIES:
:HASH:     8f143b04a318949ab557c47146ca66aa
:MODIFIED: [2021-06-28 Mon 14:06]
:ID:       815f1508-0bb3-4393-9c3e-1fc393b32b72
:END:

Guix supports the concept of [[https://guix.gnu.org/manual/en/html_node/Channels.html#Channels][channels]] which basically amount to Git
repositories which contain Guix package definitions that can be
installed on your machine.  Aside from the =%default-channels= list, I
also use the [[https://gitlab.com/nonguix/nonguix][Nonguix]] channel to install packages that aren't included
with Guix by default like the non-free Linux kernel.

*.config/guix/channels.scm:*

#+begin_src scheme :tangle .config/guix/channels.scm

    ;; NOTE: This file is generated from ~/.dotfiles/System.org.  Please see commentary there.

    (list (channel
            (name 'channel-x)
            (url "file:///home/daviwil/Projects/Code/channel-x"))
          (channel
            (name 'flat)
            (url "https://github.com/flatwhatson/guix-channel.git")
            (commit
              "7b8353ebbcf486e3344924d1cac0fa7ba47c371d")
            (introduction
              (make-channel-introduction
                "33f86a4b48205c0dc19d7c036c85393f0766f806"
                (openpgp-fingerprint
                  "736A C00E 1254 378B A982  7AF6 9DBE 8265 81B6 4490"))))
          (channel
            (name 'nonguix)
            (url "https://gitlab.com/nonguix/nonguix"))
          (channel
            (name 'guix)
            (url "https://git.savannah.gnu.org/git/guix.git")
            ;; (url "file:///home/daviwil/Projects/Code/guix"))
            (introduction
              (make-channel-introduction
                "9edb3f66fd807b096b48283debdcddccfea34bad"
                (openpgp-fingerprint
                  "BBB0 2DDF 2CEA F6A8 0D1D  E643 A2A0 6DF2 A33A 54FA")))))

#+end_src

The following channel list can be used when testing patches to
packages and services from a local clone of the Guix repo.  You'll
have to create a branch and commit changes to it before =guix pull= can
pick them up, though.  You can change the target branch using the
=branch= field of the =channel=.

#+begin_src scheme :tangle .config/guix/channels.scm

;; (list (channel
;;         (name 'nonguix)
;;         (url "https://gitlab.com/nonguix/nonguix"))
;;       (channel
;;         (name 'guix)
;;         (branch "fix-glu-pkg-config")
;;         (url "file:///home/daviwil/Projects/Code/guix")
;;         (introduction
;;           (make-channel-introduction
;;             "d06d5db885e4b8399e878708862fbe3a67f0592c"
;;             (openpgp-fingerprint
;;               "53C4 1E6E 41AA FE55 335A  CA5E 446A 2ED4 D940 BF14")))))

#+end_src

* Systems
:PROPERTIES:
:HASH:     81a4ca4e8ec72700eb8a9df390519fd3
:MODIFIED: [2021-06-28 Mon 14:14]
:ID:       b1bbb042-5f77-4b29-9902-8a549a6c46a7
:END:

** Base Configuration
:PROPERTIES:
:HASH:     6c67aadc29b087eccd4aa3906e6fec57
:MODIFIED: [2021-06-29 Tue 15:06]
:ID:       7b3733c7-0170-474c-ba33-ef72d6ba62b7
:END:

This base configuration is shared between all of the machines I manage
with Guix.  Since all of my machines are Lenovo ThinkPad laptops, the
same basic configuration applies pretty cleanly across all of them.
This may change in the future.

Any configuration that derives from =base-operating-system= must invoke
=guix system= in a specific way to ensure it gets loaded correctly:

#+begin_src sh

sudo -E guix system -L ~/.dotfiles/.config/guix/systems reconfigure ~/.dotfiles/.config/guix/systems/davinci.scm

#+end_src

*.config/guix/systems/base-system.scm:*

#+begin_src scheme :tangle .config/guix/systems/base-system.scm

;; NOTE: This file is generated from ~/.dotfiles/System.org.  Please see commentary there.

(define-module (base-system)
  #:use-module (gnu)
  #:use-module (srfi srfi-1)
  #:use-module (gnu system nss)
  #:use-module (gnu services pm)
  #:use-module (gnu services cups)
  #:use-module (gnu services desktop)
  #:use-module (gnu services docker)
  #:use-module (gnu services networking)
  #:use-module (gnu services virtualization)
  #:use-module (gnu packages wm)
  #:use-module (gnu packages cups)
  #:use-module (gnu packages vim)
  #:use-module (gnu packages gtk)
  #:use-module (gnu packages xorg)
  #:use-module (gnu packages emacs)
  #:use-module (gnu packages file-systems)
  #:use-module (gnu packages gnome)
  #:use-module (gnu packages mtools)
  #:use-module (gnu packages linux)
  #:use-module (gnu packages audio)
  #:use-module (gnu packages gnuzilla)
  #:use-module (gnu packages pulseaudio)
  #:use-module (gnu packages web-browsers)
  #:use-module (gnu packages version-control)
  #:use-module (gnu packages package-management)
  #:use-module (nongnu packages linux)
  #:use-module (nongnu system linux-initrd))

(use-service-modules nix)
(use-service-modules desktop xorg)
(use-package-modules certs)
(use-package-modules shells)

#+end_src

Add a =udev= rule to enable members of the =video= group to control screen
brightness.

#+begin_src scheme :tangle .config/guix/systems/base-system.scm

;; Allow members of the "video" group to change the screen brightness.
(define %backlight-udev-rule
  (udev-rule
   "90-backlight.rules"
   (string-append "ACTION==\"add\", SUBSYSTEM==\"backlight\", "
                  "RUN+=\"/run/current-system/profile/bin/chgrp video /sys/class/backlight/%k/brightness\""
                  "\n"
                  "ACTION==\"add\", SUBSYSTEM==\"backlight\", "
                  "RUN+=\"/run/current-system/profile/bin/chmod g+w /sys/class/backlight/%k/brightness\"")))

#+end_src

Override the default =%desktop-services= to add the =udev= backlight
configuration and include OpenVPN in the list of NetworkManager
plugins.

#+begin_src scheme :tangle .config/guix/systems/base-system.scm

  (define %my-desktop-services
    (modify-services %desktop-services
                     (elogind-service-type config =>
                                           (elogind-configuration (inherit config)
                                                                  (handle-lid-switch-external-power 'suspend)))
                     (udev-service-type config =>
                                        (udev-configuration (inherit config)
                                                            (rules (cons %backlight-udev-rule
                                                                         (udev-configuration-rules config)))))
                     (network-manager-service-type config =>
                                                   (network-manager-configuration (inherit config)
                                                                                  (vpn-plugins (list network-manager-openvpn))))))

#+end_src

Use the =libinput= driver for all input devices since it's a bit more
modern than the default.

#+begin_src scheme :tangle .config/guix/systems/base-system.scm

  (define %xorg-libinput-config
    "Section \"InputClass\"
    Identifier \"Touchpads\"
    Driver \"libinput\"
    MatchDevicePath \"/dev/input/event*\"
    MatchIsTouchpad \"on\"

    Option \"Tapping\" \"on\"
    Option \"TappingDrag\" \"on\"
    Option \"DisableWhileTyping\" \"on\"
    Option \"MiddleEmulation\" \"on\"
    Option \"ScrollMethod\" \"twofinger\"
  EndSection
  Section \"InputClass\"
    Identifier \"Keyboards\"
    Driver \"libinput\"
    MatchDevicePath \"/dev/input/event*\"
    MatchIsKeyboard \"on\"
  EndSection
  ")

#+end_src

Define the =base-operating-system= which will be inherited by all
machine configurations.

#+begin_src scheme :tangle .config/guix/systems/base-system.scm

  (define-public base-operating-system
    (operating-system
     (host-name "tsuga")
     (timezone "America/New_York")
     (locale "en_US.utf8")

     ;; Use non-free Linux and firmware
     (kernel linux)
     (firmware (list linux-firmware))
     (initrd microcode-initrd)

     ;; Choose US English keyboard layout.  The "altgr-intl"
     ;; variant provides dead keys for accented characters.
     (keyboard-layout (keyboard-layout "us" "altgr-intl" #:model "thinkpad"))

     ;; Use the UEFI variant of GRUB with the EFI System
     ;; Partition mounted on /boot/efi.
     (bootloader (bootloader-configuration
                  (bootloader grub-efi-bootloader)
                  (target "/boot/efi")
                  (keyboard-layout keyboard-layout)))


     ;; Guix doesn't like it when there isn't a file-systems
     ;; entry, so add one that is meant to be overridden
     (file-systems (cons*
                    (file-system
                     (mount-point "/tmp")
                     (device "none")
                     (type "tmpfs")
                     (check? #f))
                    %base-file-systems))

     (users (cons (user-account
                   (name "tminor")
                   (comment "Thomas Minor")
                   (group "users")
                   (home-directory "/home/tminor")
                   (supplementary-groups '(
                                           "wheel"     ;; sudo
                                           "netdev"    ;; network devices
                                           "kvm"
                                           "tty"
                                           "input"
                                           "docker"
                                           "realtime"  ;; Enable realtime scheduling
                                           "lp"        ;; control bluetooth devices
                                           "audio"     ;; control audio devices
                                           "video")))  ;; control video devices

                  %base-user-accounts))

     ;; Add the 'realtime' group
     (groups (cons (user-group (system? #t) (name "realtime"))
                   %base-groups))

     ;; Install bare-minimum system packages
     (packages (append (list
                        git
                        ntfs-3g
                        exfat-utils
                        fuse-exfat
                        stow
                        vim
                        emacs
                        xterm
                        bluez
                        bluez-alsa
                        pulseaudio
                        tlp
                        xf86-input-libinput
                        nss-certs     ;; for HTTPS access
                        gvfs)         ;; for user mounts
                       %base-packages))

     ;; Use the "desktop" services, which include the X11 log-in service,
     ;; networking with NetworkManager, and more
     (services (cons* (service slim-service-type
                               (slim-configuration
                                (xorg-configuration
                                 (xorg-configuration
                                  (keyboard-layout keyboard-layout)
                                  (extra-config (list %xorg-libinput-config))))))
                      (service tlp-service-type
                               (tlp-configuration
                                (cpu-boost-on-ac? #t)
                                (wifi-pwr-on-bat? #t)))
                      (pam-limits-service ;; This enables JACK to enter realtime mode
                       (list
                        (pam-limits-entry "@realtime" 'both 'rtprio 99)
                        (pam-limits-entry "@realtime" 'both 'memlock 'unlimited)))
                      (extra-special-file "/usr/bin/env"
                                          (file-append coreutils "/bin/env"))
                      (service thermald-service-type)
                      (service docker-service-type)
                      (service libvirt-service-type
                               (libvirt-configuration
                                (unix-sock-group "libvirt")
                                (tls-port "16555")))
                      (service cups-service-type
                               (cups-configuration
                                (web-interface? #t)
                                (extensions
                                 (list cups-filters))))
                      (service nix-service-type)
                      (bluetooth-service #:auto-enable? #t)
                      (remove (lambda (service)
                                (eq? (service-kind service) gdm-service-type))
                              %my-desktop-services)))

     ;; Allow resolution of '.local' host names with mDNS
     (name-service-switch %mdns-host-lookup-nss)))

#+end_src

** Machines
:PROPERTIES:
:HASH:     1c88bd8f06d12a2e3e4ff15d80df0144
:MODIFIED: [2021-06-28 Mon 14:14]
:ID:       a3bd0eca-4435-46f3-9c66-7188ee68e3da
:END:

*** Per-System Settings
:PROPERTIES:
:HASH:     89c32a4d7596262546ce79746f23a211
:MODIFIED: [2021-06-28 Mon 14:14]
:ID:       d6069ff1-5433-4546-9678-1e68249890c7
:END:

Some settings need to be customized on a per-system basis without
tweaking individual configuration files.  Thanks to =org-mode='s =noweb=
functionality, I can define a set of variables that can be tweaked for
each system and applied across these configuration files when they get
generated.

*** tsuga
:PROPERTIES:
:HASH:     f9834c031f586ca73ec2653d8596f31c
:MODIFIED: [2021-06-28 Mon 14:06]
:ID:       09cb9844-acdd-421f-9ae7-2e7cb20f5506
:END:

= tsuga= is a 5th Generation ThinkPad X1 Carbon that I use for system
testing and Guix demonstrations for System Crafters.

*.config/guix/systems/tsuga.scm:*

#+begin_src scheme :tangle .config/guix/systems/tsuga.scm

  ;; NOTE: This file is generated from ~/.dotfiles/System.org.  Please see commentary there.

  (define-module (tsuga)
    #:use-module (base-system)
    #:use-module (gnu))

  (operating-system
   (inherit base-operating-system)
   (host-name "tsuga")

   (mapped-devices
    (list (mapped-device
           (source (uuid "039d3ff8-0f90-40bf-89d2-4b2454ada6df"))
           (target "system-root")
           (type luks-device-mapping))))

   (file-systems (cons*
                  (file-system
                   (device (file-system-label "tsuga"))
                   (mount-point "/")
                   (type "ext4")
                   (dependencies mapped-devices))
                  (file-system
                   (device "/dev/nvme0n1p1")
                   (mount-point "/boot/efi")
                   (type "vfat"))
                  %base-file-systems)))

#+end_src

** USB Installation Image
:PROPERTIES:
:HASH:     bea1562d01ee275894cc16c3c32362c7
:MODIFIED: [2021-06-28 Mon 14:06]
:ID:       471b5309-6506-4421-a0b3-6c0e0838f13c
:END:

To install Guix on another machine, you should first build need a USB
image.  Since I use modern laptops that require non-free components, I
have to build a custom installation image with the full Linux kernel.
I also include a few other programs that are useful for the
installation process.  I adapted this image from [[https://gitlab.com/nonguix/nonguix/blob/master/nongnu/system/install.scm][one found on the
Nonguix repository]], hence the copyright header.

*.config/guix/systems/install.scm:*

#+begin_src scheme :tangle .config/guix/systems/install.scm

  ;;; Copyright © 2019 Alex Griffin <a@ajgrf.com>
  ;;; Copyright © 2019 Pierre Neidhardt <mail@ambrevar.xyz>
  ;;; Copyright © 2019 David Wilson <david@daviwil.com>
  ;;;
  ;;; This program is free software: you can redistribute it and/or modify
  ;;; it under the terms of the GNU General Public License as published by
  ;;; the Free Software Foundation, either version 3 of the License, or
  ;;; (at your option) any later version.
  ;;;
  ;;; This program is distributed in the hope that it will be useful,
  ;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;;; GNU General Public License for more details.
  ;;;
  ;;; You should have received a copy of the GNU General Public License
  ;;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

  ;; Generate a bootable image (e.g. for USB sticks, etc.) with:
  ;; $ guix system disk-image nongnu/system/install.scm

  (define-module (nongnu system install)
    #:use-module (gnu system)
    #:use-module (gnu system install)
    #:use-module (gnu packages version-control)
    #:use-module (gnu packages vim)
    #:use-module (gnu packages curl)
    #:use-module (gnu packages emacs)
    #:use-module (gnu packages linux)
    #:use-module (gnu packages mtools)
    #:use-module (gnu packages package-management)
    #:use-module (nongnu packages linux)
    #:export (installation-os-nonfree))

  (define installation-os-nonfree
    (operating-system
      (inherit installation-os)
      (kernel linux)
      (firmware (list linux-firmware))

      ;; Add the 'net.ifnames' argument to prevent network interfaces
      ;; from having really long names.  This can cause an issue with
      ;; wpa_supplicant when you try to connect to a wifi network.
      (kernel-arguments '("quiet" "modprobe.blacklist=radeon" "net.ifnames=0"))

      ;; Add some extra packages useful for the installation process
      (packages
       (append (list exfat-utils fuse-exfat git curl stow vim emacs-no-x-toolkit)
               (operating-system-packages installation-os)))))

  installation-os-nonfree

#+end_src

* Profile Management
:PROPERTIES:
:HASH:     9b6eb5117f93f2705e7bc250c7bed6c5
:MODIFIED: [2021-06-28 Mon 14:14]
:ID:       30324850-22a9-41f9-b55e-fa2068911f38
:END:

I like to separate my packages into separate manifests that get
installed as profiles which can be updated independently.  These
profiles get installed under the =~/.guix-extra-profiles= path and
sourced by my =~/.profile= when I log in.

To make the management of multiple profiles easier, I've created a
couple of shell scripts:

** Activating Profiles
:PROPERTIES:
:HASH:     d569deb3fe283f1e4632158dc3ecaee8
:MODIFIED: [2021-06-28 Mon 14:07]
:ID:       2f87f6a2-0347-49bb-a4e9-d9c63b71ae25
:END:

This script accepts a space-separated list of manifest file names
(without extension) under the =~/.config/guix/manifests= folder and then
installs those profiles for the first time.  For example:

#+begin_src sh

activate-profiles desktop emacs music

#+end_src

*.local/bin/activate-profiles:*

#+begin_src sh :tangle .local/bin/activate-profiles :shebang #!/bin/sh

  # NOTE: This file is generated from ~/.dotfiles/System.org.  Please see commentary there.

  GREEN='\033[1;32m'
  RED='\033[1;30m'
  NC='\033[0m'
  GUIX_EXTRA_PROFILES=$HOME/.guix-extra-profiles

  profiles=$*
  if [[ $# -eq 0 ]]; then
      profiles="$HOME/.config/guix/manifests/*.scm";
  fi

  for profile in $profiles; do
    # Remove the path and file extension, if any
    profileName=$(basename $profile)
    profileName="${profileName%.*}"
    profilePath="$GUIX_EXTRA_PROFILES/$profileName"
    manifestPath=$HOME/.config/guix/manifests/$profileName.scm

    if [ -f $manifestPath ]; then
      echo
      echo -e "${GREEN}Activating profile:" $manifestPath "${NC}"
      echo

      mkdir -p $profilePath
      guix package --manifest=$manifestPath --profile="$profilePath/$profileName"

      # Source the new profile
      GUIX_PROFILE="$profilePath/$profileName"
      if [ -f $GUIX_PROFILE/etc/profile ]; then
          . "$GUIX_PROFILE"/etc/profile
      else
          echo -e "${RED}Couldn't find profile:" $GUIX_PROFILE/etc/profile "${NC}"
      fi
    else
      echo "No profile found at path" $profilePath
    fi
  done

#+end_src

** Updating Profiles
:PROPERTIES:
:HASH:     9458474d45bf4b9953759b459998ae99
:MODIFIED: [2021-06-28 Mon 14:07]
:ID:       95136268-6ac3-46a8-af7a-ead0b869d417
:END:

This script accepts a space-separated list of manifest file names
(without extension) under the =~/.config/guix/manifests= folder and then
installs any updates to the packages contained within them.  If no
profile names are provided, it walks the list of profile directories
under =~/.guix-extra-profiles= and updates each one of them.

#+begin_src sh

update-profiles emacs

#+end_src

*.local/bin/update-profiles:*

#+begin_src sh :tangle .local/bin/update-profiles :shebang #!/bin/sh

  # NOTE: This file is generated from ~/.dotfiles/System.org.  Please see commentary there.

  GREEN='\033[1;32m'
  NC='\033[0m'
  GUIX_EXTRA_PROFILES=$HOME/.guix-extra-profiles

  profiles=$*
  if [[ $# -eq 0 ]]; then
      profiles="$GUIX_EXTRA_PROFILES/*";
  fi

  for profile in $profiles; do
    profileName=$(basename $profile)
    profilePath=$GUIX_EXTRA_PROFILES/$profileName

    echo
    echo -e "${GREEN}Updating profile:" $profilePath "${NC}"
    echo

    guix package --profile="$profilePath/$profileName" --manifest="$HOME/.config/guix/manifests/$profileName.scm"
  done

#+end_src

* Dotfiles Management
:PROPERTIES:
:HASH:     4d82acfbe65a9efb1d253b2056ddad2a
:MODIFIED: [2021-06-28 Mon 14:14]
:ID:       a159517b-e93f-49d3-8c95-ec92efb6657e
:END:

Since I keep all of my important configuration files in Org Mode code
blocks, I have to ensure that the real configuration files are kept up
to date when I sync the latest changes to my [[https://github.com/daviwil/dotfiles][dotfiles]] repo.  I've
written a couple of scripts to simplify that process:

** Syncing
:PROPERTIES:
:HASH:     4ab15201ca69a1694bf212a7e99f8cf3
:MODIFIED: [2021-06-28 Mon 14:07]
:ID:       bdd56eda-4701-4bed-931b-805853963ab0
:END:

When I want to sync my dotfiles repo into my local clone which likely
has uncommitted changes, I run =sync-dotfiles=.  This script first makes
sure that all Org files are saved in a running Emacs instance and then
stashes everything before pulling the latest changes from =origin=.
After pulling, the stash is popped and then the script verifies there
are no merge conflicts from the stash before proceeding.  If there are
no conflicts, =update-dotfiles= is run, otherwise I'll fix the merge
conflicts manually and run =update-dotfiles= myself.

*.local/bin/sync-dotfiles*

#+begin_src sh :tangle .local/bin/sync-dotfiles :shebang #!/bin/sh

  # Sync dotfiles repo and ensure that dotfiles are tangled correctly afterward

  GREEN='\033[1;32m'
  BLUE='\033[1;34m'
  RED='\033[1;30m'
  NC='\033[0m'

  # Navigate to the directory of this script (generally ~/.dotfiles/.local/bin)
  cd $(dirname $(readlink -f $0))
  cd ..

  echo
  echo -e "${BLUE}Saving Org buffers if Emacs is running...${NC}"
  emacsclient -u -e "(org-save-all-org-buffers)" -a "echo 'Emacs is not currently running'"

  echo -e "${BLUE}Stashing existing changes...${NC}"
  stash_result=$(git stash push -m "sync-dotfiles: Before syncing dotfiles")
  needs_pop=1
  if [ "$stash_result" = "No local changes to save" ]; then
      needs_pop=0
  fi

  echo -e "${BLUE}Pulling updates from dotfiles repo...${NC}"
  echo
  git pull origin master
  echo

  if [[ $needs_pop -eq 1 ]]; then
      echo -e "${BLUE}Popping stashed changes...${NC}"
      echo
      git stash pop
  fi

  unmerged_files=$(git diff --name-only --diff-filter=U)
  if [[ ! -z $unmerged_files ]]; then
     echo -e "${RED}The following files have merge conflicts after popping the stash:${NC}"
     echo
     printf %"s\n" $unmerged_files  # Ensure newlines are printed
  else
      update-dotfiles
  fi

#+end_src

** Updating
:PROPERTIES:
:HASH:     90cc46d2434d51efef836078c4f95a52
:MODIFIED: [2021-06-28 Mon 14:07]
:ID:       2190db69-d610-414c-9ffd-228448bc0617
:END:

Updating my dotfiles requires running a script in Emacs to loop over
all of my literate configuration =.org= files and run
=org-babel-tangle-file= to make sure all of my configuration files are
up to date.

*.local/bin/update-dotfiles*

#+begin_src sh :tangle .local/bin/update-dotfiles :shebang #!/bin/sh

  # Navigate to the directory of this script (generally ~/.dotfiles/.local/bin)
  cd $(dirname $(readlink -f $0))
  cd ..

  # The heavy lifting is done by an Emacs script
  emacs -Q --script ./.emacs.d/tangle-dotfiles.el

  # Make sure any running Emacs instance gets updated settings
  emacsclient -e '(load-file "~/.emacs.d/per-system-settings.el")' -a "echo 'Emacs is not currently running'"

  # Update configuration symlinks
  stow .

#+end_src

*.emacs.d/tangle-dotfiles.el*

#+begin_src emacs-lisp :tangle .emacs.d/tangle-dotfiles.el

  (require 'org)
  (load-file "~/.dotfiles/.emacs.d/lisp/tm-settings.el")

  ;; Don't ask when evaluating code blocks
  (setq org-confirm-babel-evaluate nil)

  (let* ((dotfiles-path (expand-file-name "~/.dotfiles"))
	 (org-files (directory-files dotfiles-path nil "\\.org$")))

    (defun tm/tangle-org-file (org-file)
      (message "\n\033[1;32mUpdating %s\033[0m\n" org-file)
      (org-babel-tangle-file (expand-file-name org-file dotfiles-path)))

    ;; Tangle Systems.org first
    (tm/tangle-org-file "Systems.org")

    (dolist (org-file org-files)
      (unless (member org-file '("README.org" "Systems.org"))
      	(tm/tangle-org-file org-file))))

#+end_src

* Nix Package Manager
:PROPERTIES:
:HASH:     68bf55844d19ae76dcd6097492d8b2f1
:MODIFIED: [2021-06-28 Mon 14:06]
:ID:       69df9aab-dc16-46f8-87a7-d2241795ac1c
:END:

In an ironic twist of fate, I've found that certain tools I need to
use are more easily available in the Nix package repository, so I use
it to install them.

#+begin_src conf :tangle .nix-channels

https://nixos.org/channels/nixpkgs-unstable nixpkgs

#+end_src

The channel needs to be updated before any packages can be installed:

#+begin_src sh

nix-channel --update

#+end_src

Installing packages:

#+begin_src sh

nix-env -i nodejs dotnet-sdk gh hledger
# nix-env -iA nixpkgs.nodejs-12_x # For a specific version

#+end_src

* System Installation
:PROPERTIES:
:HASH:     619aab381f12ad53462aa012bc1bf680
:MODIFIED: [2021-06-28 Mon 14:14]
:ID:       ec438bc8-f42f-4629-9cc4-f1226bfc8596
:END:

Here's a guide for how I install my GNU Guix systems from scratch.
This process is simplified because I've already prepared a reusable
system configuration so you might need to do extra work if you end up
following this for your own system install.

** Building the Installation Image
:PROPERTIES:
:HASH:     360ea52f6821cb3844cf42c252393d6e
:MODIFIED: [2021-06-28 Mon 14:14]
:ID:       a3886877-0f25-4d02-9f96-010bdde7eb81
:END:

Since I use modern Thinkpads, I have to use the non-free kernel and
firmware blobs from the [[https://gitlab.com/nonguix/nonguix][nonguix]] channel.  After cloning the repo, the
installation image can be built with this command:

#+begin_src sh

  # Create a slightly larger install image to have some headroom
  # for temporary file creation and avoid "no space free" errors
  guix system image ./install.scm --image-size=5G

#+end_src

*NOTE:* It can take an hour or more for this to complete, so be
patient...

Once the build is complete, Guix will print out the path to the disk
image file that was created.  You can now write the installation image
to a USB stick using =dd=:

#+begin_src sh

  sudo dd if=/gnu/store/nyg6jv3a4l0pbcvb0x7jfsb60k9qalga-disk-image of=/dev/sdX status=progress

#+end_src

** Installing Guix
:PROPERTIES:
:HASH:     b1438f463c6d0cbb69a663c983b81a5d
:MODIFIED: [2021-06-28 Mon 14:14]
:ID:       b6a9676e-4cea-4c91-bbd4-79b07b49aaee
:END:

With the newly "burned" installation image, boot from the USB drive
and choose "Install using the shell based process."

*** Setting up WiFi
:PROPERTIES:
:HASH:     97ec181ec3eb55239b4c8f0f9de5f195
:MODIFIED: [2021-06-28 Mon 14:14]
:ID:       bdd8b82c-fd89-414b-936e-3f7c995bb996
:END:

Use an editor (or =echo=) to create a new file called =wifi.conf= to store
the wifi configuration.  Make sure to set =ssid= to the name of your
wifi access point and =psk= to the passphrase for your wifi.  You may
also need to change the =key_mgmt= parameter depending on the type of
authentication your wifi router supports ([[https://wiki.archlinux.org/index.php/Wpa_supplicant#Configuration][some examples]] on Arch Wiki).

#+begin_src

  network={
    ssid="ssid-name"
    key_mgmt=WPA-PSK
    psk="unencrypted passphrase"
  }

#+end_src

First, run the following commands to unblock the wifi card, determine
its device name, and connect using the device name you received from
=ifconfig -a=.  In my case it's =wlp4s0= so I run the command like so:

#+begin_src sh

  rfkill unblock all
  ifconfig -a
  wpa_supplicant -c wifi.conf -i wlp4s0 -B

#+end_src

#+begin_quote

*NOTE:* If for any reason running =wpa_supplicant= fails, make sure to
kill any background instances of it before trying to run it again
because the old instances will block new runs from working.  This
wasted a couple hours of my time the first time I tried installing
Guix!

#+end_quote

The last step to set up networking is to run =dhclient= to turn on DNS
for your wifi connection:

#+begin_src sh

  dhclient -v wlp4s0

#+end_src

*** Setting Up Partitions
:PROPERTIES:
:HASH:     2d0994807ebc329265824e5afef6018a
:MODIFIED: [2021-06-28 Mon 14:14]
:ID:       6806acd6-7fff-460b-97c7-4d315f634702
:END:

Since we're installing on a ThinkPad with UEFI, follow the
[[https://guix.gnu.org/manual/en/guix.html#Disk-Partitioning][instructions in the Guix manual]] for disk partitioning.  The short of
it is that you need to use =cfdisk= to create a partition in your free
space:

#+begin_src sh

  cfdisk /dev/nvme0n1

#+end_src

Once you have your Linux root partition set up, you can enable LUKS to
encrypt that partition by running the following commands (where
=/dev/nvme0n1p5= is your root partition and =system-root= is an arbitrary
label you'd like to use for it):

#+begin_src sh

  cryptsetup luksFormat /dev/nvme0n1p5
  cryptsetup open --type luks /dev/nvme0n1p5 system-root
  mkfs.ext4 -L system-root /dev/mapper/system-root
  mount LABEL=system-root /mnt

#+end_src

Finally, make sure to mount your EFI partition to =/mnt/boot= so that
the installer can install the bootloader.  The Guix installation
instructions obscure this step slightly so it's easy to miss:

#+begin_src sh

  mkdir -p /mnt/boot/efi
  mount /dev/<EFI partition> /mnt/boot/efi

#+end_src

Now your EFI and encrypted root filesystems are mounted so you can
proceed with system installation.  You must now set up the
installation enviornment using =herd=:

#+begin_src sh

  herd start cow-store /mnt

#+end_src

*** Initial System Installation
:PROPERTIES:
:HASH:     e0a51d75ab33d7f73ca22f0cb3ec3da0
:MODIFIED: [2021-06-28 Mon 14:14]
:ID:       7ec36fe0-55ce-4f4e-a9e5-74683affbd4a
:END:

If you've got a system configuration prepared already, you can use =git=
to pull it down into the current directory (the one you're already in,
not =/mnt=):

#+begin_src sh

  git clone https://github.com/daviwil/dotfiles

#+end_src

One important step before you attempt system installation is to set up
the =nonguix= channel so that the system can be installed from it.  Once
you've cloned your dotfiles repo, you can place your =channels.scm= file
into the root user's =.config/guix= path and then run =guix pull= to
activate it:

#+begin_src sh

  mkdir -p ~/.config/guix
  cp dotfiles/guix/channels.scm ~/.config/guix
  guix pull
  hash guix  # This is necessary to ensure the updated profile path is active!

#+end_src

The pull operation may take a while depending on how recently you
generated your installation USB image (if packages in the main Guix
repository have been updated since then).

Once your channels are set up, you will need to tweak your
configuration to reflect the partition UUIDs and labels for the system
that you are installing.  To figure out the UUID of your encrypted
root partition, you can use the following command:

#+begin_src sh

  cryptsetup luksUUID /dev/<root partition>

#+end_src

#+begin_quote

**TIP:** To make it easier to copy the UUID into your config file, you
can switch to another tty using =Ctrl-Alt-F4= and press =Enter= to get to
another root prompt.  You can then switch back and forth between the
previous TTY on =F3=.

#+end_quote

Now you can initialize your system using the following command:

#+begin_src sh

  guix system -L ~/.dotfiles/.config/guix/systems init path/to/config.scm /mnt

#+end_src

This could take a while, so make sure your laptop is plugged in and
let it run.  If you see any errors during installation, don't fret,
you can usually resume from where you left off because your Guix store
will have any packages that were already installed.

*** Initial System Setup
:PROPERTIES:
:HASH:     92ea40fe9d60684dd6dfbe456989d38a
:MODIFIED: [2021-06-28 Mon 14:14]
:ID:       cb7afb89-60f5-481f-b665-3be5d5989caf
:END:

Congrats!  You now have a new Guix system installed, reboot now to
complete the initial setup of your user account.

The first thing you'll want to do when you land at the login prompt is
login as =root= and immediately change the =root= and user passwords using
=passwd= (there isn't a root password by default!):

#+begin_src sh

  passwd             # Set passwd for 'root'
  passwd <username>  # Set password for your user account (no angle brackets)

#+end_src

Now log into your user account and clone your dotfiles repository.

Since we used the =nonguix= channel to install the non-free Linux
kernel, we'll need to make sure that channel is configured in our user
account so that we have access to those packages the next time we =guix
pull=.  At the moment I just symlink the Guix config folder from my
=.dotfiles= to =~/.config/guix=:

#+begin_src sh

  ln -sf ~/.dotfiles/guix ~/.config/guix

#+end_src

Verify that your =channels.scm= file is in the target path
(=~/.config/guix/channels.scm=) and then run =guix pull= to sync in the
new channel.

Now you can install the packages that you want to use for day-to-day
activities.  I separate different types of packages into individual
manifest files and manage them with my =activate-profiles= script:

#+begin_src sh

  activate-profiles desktop emacs

#+end_src

Now the packages for these manifests will be installed and usable.
They can be updated in the future by using the =update-profiles= script.
